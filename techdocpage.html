<!DOCTYPE html>
<html>
<head>
    <link rel ="stylesheet" type="text/css" href="techdocpage.css">

</head>

<body>   
    <h2 class="doc-title">Float Flex and Grid</h2>
<main id="main-doc">
    
    <nav id="navbar">
      <ul>
        <li class="list-header"><header>Float Flex Grid</header></li>  
        <li><a class="nav-link" href="#Introduction"> Introduction </a></li>
        <li><a class="nav-link" href="#Best_is_Relative"> Best is Relative </a></li>
        <li><a class="nav-link" href="#Floats"> Floats </a></li>
        <li><a class="nav-link" href="#Float_Examples"> Float Examples </a></li>
        <li><a class="nav-link" href="#Flex"> Flex </a></li>
        <li><a class="nav-link" href="#Flex_Examples"> Flex Examples </a></li>
        <li><a class="nav-link" href="#Grid"> Grid </a></li>
        <li><a class="nav-link" href="#Grid_Examples"> Grid Examples </a></li>
        <li><a class="nav-link" href="#Flex_with_Grid"> Flex with Grid </a></li>
        <li id="last-list"><a class="nav-link" href="#Wrapping_Up"> Wrapping Up </a></li>  
      </ul> 
    </nav>  
    
    <style>
      @media (min-width:900px){
        #main-doc{
          grid-template-columns: 1fr 2fr;
         
        } 
        #navbar{
            border-right: 2px solid grey;
            top:0;
            border-bottom:none;
            height:100%; 
            overflow-x: hidden;
            overflow-y: scroll;
            position:fixed;
        }
        ul{
          flex-direction:column;
          justify-content: space-around;
          text-align: center;
          height:100%;
          overflow-y: scroll;
         }
         .wrapper{
             grid-column: 2/ 4;
         }
    
    }  
      
    </style>
      <div class="wrapper">
            <section class="main-section"id="Introduction">
                <header>Introduction</header> 
                    <p>
                       In this article, we will go over some of the highlights of Float, Flex, and Grid.
                        In the simplest terms, these three HTML/CSS features are used to organize the elements on our Webpage.
                        As we will see in the following paragraph, some of these features are more efficient in certain situations
                        than others.<br>
                            <h4>What you will need.</h4>
                                <ul id="paragraph-lists">
                                    <li class="pli">A basic understanding of html.</li>
                                    <li class="pli">A basic understanding of css.</li>
                                </ul>
                
                    </p>  
        
            </section> 
            <section class="main-section"id="Best_is_Relative">
                <header>Best is relative</header> 
                    <p>
                        Depending on the layout you are trying to achieve, using one of these features may be more efficient than another. 
                        Each of these features has drawbacks that should serve to prevent you from using it in certain situations.
                        This does not only apply to how these features affect webpage elements, but also in how easy/difficult they 
                        are to set up in the first place. Grid, as we will see, allows us to divide the elements of our webpage in two-dimensions,
                        meaning the feature can be implemented to affect both the columns and rows of a given container.
                        This might not be necessary in a situation where we only want to affect container elements according 
                        to their position along either an x or a y axis. In a situation such as this, flex might be a better decision,
                        as it is typically less time-consuming to set up than grid, but will get the job done nonetheless. An argument
                        could be made that floats are even less difficult to set up than flex, and also require less forethought before
                        implementing. This may come at the expense of more specific control of your webpage elements further on, and 
                        so it is entirely relative to your situation. I encourage you to keep that in mind as you continue reading this article.
                        </p>  
        
            </section>
            <section class="main-section"id="Floats">
                <header>Floats</header> 
                    <p>
                        The Float property was originally introduced to move block-level elements around a page more easily. As it is the oldest
                        of the features in this article, it may come as no surprise that it offers the least amount of control over webpage elements, especially
                        in relation to one another. 
                        <br><br>
                        Float, in its simplest terms, allows us to move block-level elements to either the right or the left in our webpage. This allows other content
                        to wrap around these block-level elements, which can be used to very easily create a sense of cohesion to our webpages. Before the option to float existed,
                        this could only be achieved by very specifically setting margins and padding to fixed block-elements. This, as I can only imagine, must have been very 
                        time-consuming.
                    </p>

            </section>
            <section class="main-section"id="Float_Examples">
                <header>Float Examples</header> 
                    <p>
                        Because we have less control over multiple elements simultaneously using floats, there is less syntax involved in implementing float to block-level elements.
                        First we apply the following to a given element.
                           <pre class="code"><code> display:block;</code></pre>
                    </p>
                    <p>     
                        Once we set the display of the element in question to block, we can then use float to shift it over to the right or left side of our webpage by using one of the following options:
                    </p>
                        <pre class="code"><code> float:left;</code></pre>
                        <pre class="code"><code> float:right;</code></pre>
                    
                    <p>
                        <b>NOTE</b> certain elements in html are automatically considered block-level elements. Paragraphs, headers, and forms are just a few of the long-list of elements that are inherently 
                        block-level. When floating one of these items, you do not have to set the display to block as it is already considered block-level. 
                        
                        <h4>For lists of Block and Inline html elements, click on the items below</h4>
                            <ul id="paragraph-lists">
                                <li class="pli"><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements" target="_blank"> <u> <b>Block-Level Elements</u></b> </a></li>
                                <li class="pli"><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements" target="_blank"><u><b>Inline Elements</b></u></a></li>
                            </ul>
                    </p>
        
            </section> 
            <section class="main-section"id="Flex">
                <header>Flex</header> 
                    <p>
                        Flexbox is as a one-dimensional display module. In this case, one dimensional means that it affects all elements along either a row or a column.  Although Flexbox can affect elements in either direction, it offers more control
                        over the elements that are displayed along the 'main axis'. Flexbox offers control over multiple html elements simultaneously. It functions in a parent-child relationship, with the container element being designated as the parent element, 
                        and all items within that container element as child elements. Flexbox allows for quick and easy webpage organization. Using syntax that we will see below, Flexbox is able to move multiple child elements in a certain
                        direction together, and also space each of these child items evenly along an axis. Flex also offers control over the cross-axis as well, (cross axis and main axis are terms we will visit in subsequent sections). 
                    </p> 
                    
                    <p>
                        In order to initiate Flexbox on a group of items, we must first assign the role of parent to an individual element. In order to do this, we use the following syntax on a block item that holds other items within it.
                        <pre class="code"><code> display:flex </code></pre>
                    </p>
                    <p>
                        All items within this parent element are now modified according to the specifications we make within this parent element. First we decide whether the child elements will be displayed in rows or columns. By default,
                        flex items are displayed in rows, so just initializing flex will serve to organize child elements along the x-axis. If we would prefer the items to be positioned vertically we can achieve this by entering the following syntax
                        in our flex-container.
                        <pre class="code"><code> display:flex; </code></pre> 
                        <pre class="code"><code> flex-direction:column;</code></pre>
                    </p>
                    <p>
                        After we've decided whether our flexed child-elements will be displayed in a row or column, we can further manipulate there layout in terms of there location, spacing, and even the order in which they are displayed.  We will 
                        cover some of this in the next section. 
                    </p>
            </section>
            <section class="main-section"id="Flex_Examples">
                <header>Flex Examples</header> 
                    
                        <h4>Justify Content</h4>
                    <p>
                        Justify Content allows us to select how all of our container elements are displayed along the main axis. Here, the main axis depends on the direction of our container items. If our container items are set to row, (which we saw earlier), then the 'main 
                        axis' will be the x-axis. And if our container elements are set to column, the main axis will be the y-axis.
                        
                        Some common syntax for affecting our flex items along the main axis are demonstrated below.   
                    </p>
                        <pre> <code> justify-content:flex start; </code> </pre> 
                        <pre> <code> justify-content:flex-end; </code> </pre> 
                        <pre> <code> justify-content:center; </code> </pre> 
                        
                    <p>
                        Using justify content like it is demonstrated above will move all flex items within that container to the beginning of the main axis, the end of the main axis, or to the center of the main axis respectively. Two other common ways to affect our items along the main axis include: 
                    </p>
                        <pre> <code> justify-content:space-between; </code> </pre>
                        <pre> <code> justify-content:space-around; </code> </pre>
                    <p>
                        Both space-between and space-around evenly space our items along the entirety of the main axis. The only difference between the two is that space-around will leave an additional space in between the outer most element and its closest margin along the main axis.
                    </p>
                    <hr>
                    <h4>Align Items</h4>
                    <p>
                        While justify-content affects our container items along the container's main-axis, align-items affects the location of our container items along the cross-axis. Here, the cross-axis is whichever axis is perpendicular to our main-axis. So, for flex containers that use the x-axis as the main axis, the cross-axis will be the y-axis (and vice versa).
                        <br>
                        Some common syntax for moving our container items along the cross-axis is written below: 
                    </p>
                        <pre> <code> align-items:flex-start; </code> </pre> 
                        <pre> <code> align-items:flex-end; </code> </pre>
                    <p>
                        Aligning our items will move all of them to either the beginning or the end of whatever our cross-axis is. So, for items whose main-axis is the x-axis, aligning them with "flex-start" will move them all to the top of the container.  The same is true for flex-end, with the probably obvious exception that it pushes these items toward the end of the cross-axis.
                        Another option that we have to affect our items along the cross axis is written below:
                    </p>
                        <pre> <code> align-items:stretch; </code> </pre>  
                    <p>
                        This will stretch the items so they take up all of the space of the cross-axis. <b>NOTE</b> this will only work if we set the height of the container item in question to 'auto.'
                    </p>
                    <h4>Align Self</h4>
                    <p>
                        Align-Self allows us to make the same changes that we can make using align-items but to individual container elements instead of all container elements at once. This serves to further increase our control over the display, as we don't have to set all of our container items in the same way along the cross-axis. The following can be used on any item within a flex-container.
                    </p>
                        <pre> <code> align-self:stretch </code> </pre>
                    <p>
                        This will stretch the item in question to take up the entire cross-axis without affecting any of the other flex-container elements. Align-self will work with any of the syntax that can be assigned to align-items.
                    </p>   
                    <h4>Flex-Wrap</h4>   
                    <p>
                        The last flex attribute we will be looking at is called Flex-Wrap. By default, flex automatically fits all of its container elements within one line along the main-axis. In order to change this, we can add the following to our flex container.
                    </p> 
                        <pre> <code> flex-wrap:wrap; </code> </pre>
                    <p>
                        Items within our flex container will now "wrap" around to the next main-axis line when they run out of room. We can also set the following to wrap our items in reverse order.
                    </p>
                        <pre> <code> flex-wrap:wrap-reverse; </code> </pre>
                    <p>
                        These are only the most frequently used flex-container attributes. There are more however, and I will link a site that goes into more detail <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/"target= "_blank"> <b>here.</b></a>
                    </p>    

            </section>
            <section class="main-section"id="Grid">
                <header>Grid</header> 
                    <p>
                        Grid was introduced sometime after Flex as an alternative for displaying items on our webpage. Grid is more 2-dimensional than flex, as we can specifically place all elements within our container element on both the x and y axis. This offers more precision than Flex, 
                        but it comes at the expense of taking bit of extra time to set it up. Like flex, grid is a parent-child display module, so we first set a div container as the parent element, and then we can affect all elements within that parent element, which are referred to as child-items.
                        We initiate Grid exactly like we initiate Flex but with different syntax. First, we apply the following to the container element which will serve as our parent-element.
                    </p>  
                        <pre> <code> display:grid </pre> </code>
                    <p>
                        All child elements within this parent element can now be affected using grid, which is something that we will see in more detail in the next section.
                    </p>
        
            </section>
            <section class="main-section"id="Grid_Examples">
                <header>Grid Examples</header> 
                <h4>Assigning Columns and Rows</h4>
                    <p>
                        Grid offers even more control than flex in its ability to position elements along the webpage. This is because Grid allows us to specifically place items according to their x and y position, where flex offers less initial precision. Like we mentioned earlier, we initialize grid by adding 'display:grid' to a parent-element. 
                        After this, we can immediately designate the size of our grid. We do this by specifying the amount of columns we want our grid to be divided into, and also the size of each individual column. This is achieved by entering the following syntax, which is just an example as we'll see.  
                    </p>  
                        <pre> <code> display:grid </pre> </code>
                        <pre> <code> grid-template-columns: 1fr, 2fr; </pre> </code>
                    <p>
                        In the example above our grid has two columns. One of these columns is 1fr (fractional size unit in html), and the other is 2fr. This demonstrates how grid-columns are created; with the first amount being the size of our first column, and the size of each subsequent column being the following amounts. 
                        Grid will therefore be as many columns as there are values following the "grid-template-columns" syntax, as each of these values is the size of a certain column. As you might be able to see already, we can very specifically designate the size of our space. We are not limited to size units either. 
                        We can designate the size of our columns by using any html measurement units (fr, px, % etc).  And these can even differ among the same grid template as is indicated in the following example. 
                    </p> 
                        <pre> <code> display:grid; </code> </pre>
                        <pre> <code> grid-template-columns: 1fr, 25px, 40%; </pre> </code>   
                    <p>
                        In this example we have created three different columns using three different units of measurement, allowing us full control when deciding on the size of our grid items. The same thing applies if we want to establish the size of the rows in our grid. The only exception is that where we used 'grid-template-columns' for columns, we will use 'grid-template-rows' for rows. 
                        An example set up where we have designated the size of our grid columns and rows can be seen below.
                    </p>   
                        <pre> <code> display:grid; </pre> </code>
                        <pre> <code>grid-template-columns: 1fr, 2fr; </pre> </code>
                        <pre> <code>grid-template-rows: 1fr, 2fr, 2fr, 1fr;  </pre> </code>
                    <p>
                        Here, we have decided that our grid is going to take up two columns and  four rows, and the size of each of these is written as fractions of the entire webpage page (fr).  From here we can start deciding how to place all of our items within the rows and columns that we have created.  
                    </p> 
                        <hr>  
                <h4>Grid Columns and Rows</h4> 
                    <p>
                        After we've dictated the amount of columns (and maybe rows) within our grid container, we can start organizing the items within. There are two ways we can do this. The first we will go over, is achieved simply by writing a grid-item's column and row location. We can do this using the syntax in the following example.
                    </p>
                        <pre> <code> example-item{grid-column: 1/3;grid-row: 1/4;}  </code> </pre>
                    <p>
                        This means that the item in question will start against the line of the first column and end against the last line of the second column. And this item will start against the first line of the first row and end against the last line of the third row. The above example would fit within a grid that has two columns and three rows, despite the second two numbers in both instances initially appearing to be one number higher than this amount. 
                        This is because the final line in our grid-template specifications is the outermost line of the grid, so in this example line four refers to the bottom line of the bottom row.
                    </p>
                    <br>
                <h4>Grid Template Areas</h4>
                    <p>
                        Grid-template-areas allows us to dictate which child elements will go where within our grid parent container. We organize our grid by naming which item will go in which area, and then labeling our corresponding grid items appropriately (as we will see below). Below is an example of grid-template-areas in action.
                    </p>   
                        <pre> <code>display:grid </pre> </code>
                        <pre> <code>grid-template-columns:1fr, 2fr</pre> </code>
                        <pre> <code>grid-template-areas:" item-a item-a"
                      "item-b item-c"
                      "item-d item-d"; </pre> </code>
                    <p>
                        And after this, we specify which grid item is in which grid area using the following syntax: 
                    </p> 
                        <pre> <code> .grid-example-item {grid-area:"item-a";}
                        </code> </pre> 
                    <p>
                        As we can see in the example above, we established how many columns will be in our grid, and also which of our grid items will go where within our grid. We then add grid-area to items in our grid, and set the grid-area to match the name of the 'grid-template-area' we want our item to be displayed in. In the example above, item-a will take up the entire first row of the grid, with subsequent items labeled 'item-b' and 'item-c' taking up the second row,
                        and 'item-c' taking up the entire bottom row. These items don't have to be in order in our html either, as simply dictating an item's grid-area will place it according to the parent's grid-template-area specifications. This has a lot of benefits, one of which being easier media queries. Media queries give us the ability to dictate changes to our webpage based on the size of the screen that is viewing it. Since we can easily write our grid-template-areas
                        in one list in our parent element, and these areas will determine the order and position of our grid elements, we don't have to keep rewriting a ton ofcode to fit our webpage to different screen sizes. All we have to do is create a new grid-template-area in our media query, and our grid items will move in response to it.

                        <br> <br> 
                        <b>Note</b> Media queries allow us to create more responsive webpages. For more information about media queries, click <a href="https://www.w3schools.com/css/css_rwd_mediaqueries.asp"><b><u>here.</u></b></a>
                    </p>
                    <h4>Justify Items and Align Items </h4> 
                    <p>
                        Just like we saw in an earlier section about flex, we can move our grid items together using certain syntax on our grid parent element. This is slightly different than flex, however, as we are moving the content within our already established grid containers. The first two we will look at are wrritten as follows. 
                    </p>    
                    <pre><code> display:grid; </code></pre>
                    <pre><code> justify-items:center;</code></pre>
                    <pre><code> align-items:center;</code></pre>
                    <p>
                        Justify-items aligns the items along the x-axis or the row, whereas align-items aligns items along the y-axis or the column. In the above example we used center which would push all grid items to the center of their respective cell. They both take values start, end, center, and stretch which move the items to the beginning, end, center, or 
                        make the items stretch the length of their containers respectively. 
                    </p>
                        <br>
                    <p>
                        This is just barely scratching the surface of the vast capabilites of grid containers. Below is a short list of some syntax that we haven't covered, and also a link to a more immersive dive into grid. 
                    </p>
                        <ul id="paragraph-lists">
                            <li class="pli"><u>Justify-Content</u> to position the entirety of grid elements within the overrall grid container along the x axis.</li>
                            <li class="pli"><u>Align-Content</u> to position the entirety of grid elements within the overrall grid container along the y axis. </li>
                            <li class="pli"><u>Grid-Gap</u> to create even lines between all of our grid cells.</li>
                        </ul>
                    <p>
                        <a href="https://css-tricks.com/snippets/css/complete-guide-grid/#prop-justify-content"><b><u>Here</b></u></a> is a list that goes in to much greater detail about grid.
                    </p>
                        
            </section>
            <section class="main-section"id="Flex_with_Grid">
                <header>Flex with Grid</header> 
                    <p>
                        Grid and Flex both offer massive control over the layout of our webpage individually. Both of these modules allow us to affect the position of our elements along both the x and the y axis (although with flex having more control over one axis than another). In certain situations, setting up grid may not be worth the effort, especially for 
                        simpler tasks that do not require much forethought. It is as easy as setting an element to flex, and simply dictating where all of these elements will be positioned. No adding areas to items, and taking the time to designate space for these items as we saw with grid. In other situations, grid shines with its precision. Perhaps we can be in 
                        most control of our layout while using the two together. Grid is typically good for media queries, as we discussed briefly earlier. It is a good fit when it comes to organizing a full structure, with its ability to very precisely place all elements within it. Some of these elements can be flex containers. Since flex shines in areas that do not 
                        require full control, that need quick and easy values to dial in. Placing flex within grid gives us the best of both worlds, streamlining our ability to set up smaller items in flex containers, and placing those flex containers exactly within our larger and more precise grid container. Of course this is just an opinion. Try them out for yourself
                        and see how you can use them best. 
                    </p>  
        
            </section>
            <section class="main-section"id="Wrapping_Up">
                <header>Wrapping Up</header> 
                    <p>
                        We briefly went over some of the most popular methods for positioning items within ourr html. These methods, as we have mentioned earlier, might be more well equipped for certain situations than others. As such, you should use your best discretion when picking which one to implement in a given situation. Remember you are not limited to using just 
                        one of these modules or methods for moving the content on screen. You might even have more control by using different ones together. Try it out for yourself!
                    </p>  
        
            </section>                  
  
    </div>       
  
  </main>

</body>
</html>  